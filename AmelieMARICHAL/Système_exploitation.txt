	Système d'Exploitation
SSH : Secure Shell
- Web : 80
- ftp : 21
- smtp
- pop
- s(web) secure : 443
Système de pointage de ressources unique
Apache : serveur web 
Structure client-serveur : 
Fichier de configuration pour accepter une seule adresse IP (127.0.0.1 ou localhost).
Le daemon fonctionne en tant que serveur spam et attend les requêtes de notre serveur mail qui fonctionne en tant que client. Le démon applique un statut ḋ spam Ṡ aux mails concernés qui est catégorisé par le serveur mail.
Un mail est un fichier source, ce sera toujours du texte brut. En tant qu'administrateur on utilise des outils qui manipule des textes bruts et pour aller chercher des éléments rapidement. L'interface graphique parle en ligne de commande. 
SaaS : Cloud : Manière d'accéder à un service sur Internet : Moins de données sur les machines, plus de données sur les serveurs.
Internet : années 90 ; premier service d'internet : au début des années 70
Software as a Service : On externalise les logiciels (GoogleDoc)
Hébergement :
- mutualisé : on ḋ mutualise Ṡ les ressources du serveur. Une seule machine répartit la charge pour plusieurs sites Internet
o A (serveur/daemon)/var/www/siteweb1
* Siteweb2
- dédié : une machine pour un site Internet (ḋ root Ṡ)
- virtualisé : faire virtuellement tourner un système d'exploitation sur un autre (virtual box), administrateur de notre machine mais les ressources sont partagées entre plusieurs machines virtuelles
PaaS : Platform as a Service : on n'externalise plus seulement des données comme SaaS, mais on externalise l'ensemble des services dont on a besoin pour créer une plateforme. Ex : OpenShift
IaaS : Infrastructure as a Service. Ex : Amazon


Logiciels libres : 
- modifiable
- opensource
- copyright (date de 1969, date à laquelle le gouvernement a proclamé l'Unbundling Act, pour qu'IBM n'ait pas le monopole sur le logiciel et le hardware, faisant que les deux devaient être vendus séparément)
- droits d'auteur (donne à l'utilisateur le droit de modifier le logiciel, de tout redistribuer ainsi que le droit de vendre le logiciel)
ex : Linux, openoffice, firefox, thunderbird, notepad++, vlc
code source compilé <> interprété
Création de la Free Software Foundation (85) et de GNU : GNU is Not Unix (GNU : ensemble des logiciels qui font fonctionner le système d'exploitation), formé de l'association et de la licence GPL : GNU Public Licence
GNU = début du logiciel libre
Linux = On a toujours une seule racine comparé à Windows (C:\)
Une distribution est un écosystème dans lequel il y a le système d'exploitation, couche logicielle de base pour permettre l'affichage graphique. Au coeur du SE, il y aura le noyau, gérant la carte graphique. Autour du SE, il y aura des outils. 
Debian : Deborah + Ian, couple de développeurs
Installer soit Ubuntu, Fedora, LinuxMint, ArchLinux ou Debian sous Virtual Box pour le 4 avril 
Créer une clef public avec le programme ssh-keygen
Créer un compte openshift.com (OS) : uploader votre clef public sur OS
Créer un compte sur github.com : uploader clef public sur GH
Bastien.Guerry@free.fr : envoyer un mail avec nom et prénom
Droit d'auteur : distinction entre le droit moral (intégrité de l'oeuvre) et le droit patrimonial (cession d'argent), en France. Aux US, les deux sont regroupés dans ce qu'on appelle le ḋ Copyright Ṡ. 
MacOSX : Provient de (Free) BSD (qui est la même chose que GNU Linux ou quasiment qui s'inspire d'Unix), qui est la licence la plus proche du domaine public, qui permet de faire des oeuvres dérivées sans avoir la restriction de faire des logiciels libres lorsque l'on reprend son code. 
Unix : différence entre : 
- (Free) BSD (Ouest) : Berkley Software Development : liberté totale -> MacOSX
- GNU/Linux : Est : restrictif. En 1991, Linus Torvald créé un noyau pour faire fonctionner Les outils GNU sur sa machine. 
SSH / Crypto et Git 
Chiffrements symétrique et asymétrique : 2 clefs différentes, publique et privée
Clef publique : boîte qui permet aux gens d'envoyer des messages
Clef privée : gardée sur sa machine 
Lorsque l'on est sur sa machine, on est dans un ḋ shell Ṡ. Il donne un ensemble de commandes disponibles, comme ḋ echo Ṡ qui fait partie de l'interpréteur Shell. Il y a d'autres interpréteurs comme Bash (Born again shell), Trsh.
Si on donne notre clef publique à un serveur distant, il nous connaît donc il va pouvoir chiffrer les transactions via la clef publique. Dans cette transaction, on aura la clef publique du serveur qui nous permettra alors d'envoyer aussi des éléments. 
/home/user_dist/.ssh/authorized_keys/ Dans ce répertoire, il y a notre clef publique et d'autres.
Gestionnaire de versions : CVS, Git, Subversion, mercurial, Tortoise SVN
Forge : Google Code, Github, BitBucket, Gitorious : pouvoir sauvegarder des informations de version sur le web
Il y a un dépôt central pour l'ensemble des modifications comme dans CVS, l'usage de Git se fait de la même façon avec quelques différences. Les personnes clonent le dépôt, on récupère alors tous les fichiers de ce dépôt plus tous ceux qui sont sur le répertoire.git. Clone permet de créer un miroir sur notre ordinateur. Le fait de commit permet de créer une version en local et Push permet de mettre sur le dépôt. 
Pour créer son dépôt : ''git init''
		''git add fichier.txt''
		''git commit'' (pour créer une version) + '' -m 'message''' (ajouter un message)
Tout est un fichier qui est du texte.
mkdir isep_tmp : creation d'un repository temporaire
cd isep_tmp : aller à celui-ci
isep_tmp% mkdir.
isep_tmp/isepse2014% git init : création du repository
isep_tmp/isepse2014% ls -l : regarder s'il y a des fichiers dessus
isep_tmp/isepse2014% ls -la
isep_tmp/isepse2014% git add empty.txt
isep_tmp/isepse2014% git status
git add * : permet d'ajouter tous les fichiers 
git commit (+ message -m possible)
isepse2014% cd ..cd
isep2014% git clone @...
touch bzg.txt : ajouter un fichier vide / modifier un fichier 
echo ḋ Ṡ > bzg.txt : ajouter ḋ Ṡ dans le fichier
less bzg ? 
     



grep est utilisée pour rechercher une ḋ string Ṡ dans un fichier. Ex : grep ḋ toto Ṡ filetxt
find est utilisé pour rechercher un objet dans un fichier.    Ex : find . name ḋ file.txt Ṡ ou encore find home/user/ -name ḋ .git Ṡ
chmod
globbing : rechercher un élément d'une manière globale en utilisant un raccourci
# !/bin/bash : bash est le nom de l'environnement (executable)
Pour renommer un fichier, il faut : mv file.txt filez.txt, on le déplace ḋ move Ṡ.


TP2 : 
Utilisation des lignes de commande : Lié au fait qu'avant les systèmes ne gérait pas les interfaces graphiques avant. Maintenant, certains les utilisent toujours plutôt que la souris. Les lignes de commandes sont du texte. Ce texte peut être stocké quelque part et réutilisé. Lorsquon communique avec un ordinateur sous forme de texte on peut structurer notre langage, on aura toute la puissance d'un langage de programmation.
2 grandes familles : Langage compilé comme le java. Le compilateur fait passer me programme de son état de fichier texte à un exécutable par la machine.
	Langage interprété au fur et à mesure ligne par ligne. Exécute directement la ligne du programme. Read Eval Print Loop (REPL). Bash est un interpréteur (ls : ligne de code dans un langage de programmation).
Shell considéré comme DSL : Domain Specific Language : Outil spécialisé. Permet d'intéragir avec le système d'exploitation et notamment sur ce qu'il y a sur la machine et les programmes.
Nom de fichier : Ce qui va caractériser un fichier c'est un chemin absolu pour y accéder partant de la racine. Lorsque l'on exécute un programme sous Shell on tape seulement ce qui correspond au nom du fichier mais Bash doit pouvoir savoir dans quel répertoire se trouve ce programme. On va pouvoir changer la liste des endroits où on va mettre les fichiers et où on va venir les chercher. PATH est la variable qui contient les chemins des programmes exécutables.  Les noms de variables sont en majuscule. 
On accède au contenu d'une variable d'environnement avec $ puis le nom de la variable, ici PATH.
Ce qu'on veut c'est accéder le contenu d'une variable d'environnement dont le nom est PATH. $PATH donne ḋ commande introuvable Ṡ.  Bash s'attend à trouver une commande et si on met l'accès au contenu d'une variable, il va regarder ce contenu et s'attendre que ce soit ça la commande.
Il remplace donc $PATH par le contenu de la variable PATH. On ne lui a pas demandé d'afficher le contenu de la variable, on lui a demandé d'exécuter le contenu de la variable. 
La commande la plus simple pour afficher une variable va être ḋ echo Ṡ.
Chaque variable est associée non seulement à une valeur mais aussi à un type (nombre à virgule par exemple). 
Bash ne traite quasiment que des chaînes de caractères. PATH contient un ensemble de chaînes de caractères qui décrivent des répertoires. 
On sépare les chaînes de caractères par ḋ : Ṡ. 
Bash et le Shell sont particulièrement adaptés pour traiter des fichiers qui contiennent du texte. La notion de séparateur intervient alors pour mettre en forme ce texte. Un texte contient des lignes et on aura la notion de champs dans les lignes. 

Commandes : 
Copier : cp
Lister : ls
éditeur de texte <> traitement de texte : modifier du texte brut <> rajoute la gestion de mise en page 
ex : gedit, editor
EDITOR : variable d'environnement qui gère l'éditeur
Bash est l'un des shell existants sous Linux, l'un des plus répandus. 
Pour savoir sous quel shell on est, il faut utiliser la variable d'env. SHELL et pour voir rapidement le contenu de la variable on utilise : echo $SHELL. 
etc/passwd : contient toutes les informations de connexion des utilisateurs
cat : éditeur de texte (tout comme nano)
Si on souhaite éditer un fichier, on doit mettre le nom de l'éditeur de texte avant la commande. Ici donc cat etc/passwd.
Sous bash on a ce qu'on appelle la complétion automatique, on peut donc appuyer sur la tabulation pour compléter un élément que l'on est en train de traiter.
man : commande qui va afficher la documentation d'une commande. Ex : man/false. 
Le shell bin/false est associé à tout type d'utilisateur afin qu'ils n'aient pas accès à un shell.
Rechercher tous les shell utiliser dans /etc/passwd : 
- Prendre la liste des shell avec tous les doublons : prendre le contenu de /etc/passwd et prendre le contenu de ce qui est écrit après les ḋ : Ṡ. Sélectionner les derniers champs du fichier : utilisation de la commande unix ḋ cut Ṡ : cut permet de récupérer des champs dans des lignes : ici cut -d : -f7 /etc/passwd
Le résultat de l'exécution d'une commande peut être mis dans un fichier. Cela se fait sous la forme d'une redirection de la sortie standard (flux de texte sortant, s'affichant sur le terminal) à l'intérieur d'un fichier. Cela s'effectue avec le symbole ḋ > Ṡ. ex : cut -d: -f7 /etc/passwd > allShells.txt. si le fichier n'existe pas, il sera créé dans le répertoire courant.
- Trier : commande ḋ sort Ṡ. On insère les résultats dans un autre fichier. 
Commande globale : sort allShells.txt > allShellsSorted.txt
Pour compter le nombre de doublons : uniq -c allShellsSorted.txt
Supprimer les doublons : uniq : permet de supprimer les doublons.
- Par ordre numérique décroissant : sort -nr allShellsSortedUniq.txt. -n permet de trier par ordre numérique croissant et on rajoute r (-r tout seul) 	après -n pour avoir un ordre décroissant numérique
Il faudrait brancher la sortie standard d'une commande sur l'entrée standard de la commande précédente afin de ne pas avoir tous ces fichiers. 
Pour effectuer le programme en une seule ligne : cut -f7 -d : /etc/passwd |sort|uniq -c| sort -nr
Une autre façon de rediriger la sortie standard est de remplacer le contenu du fichier soit d'écrire à la suite en utilisant overwrite et append. 
Les traces de requêtes sont stockées dans des fichiers de log.
pwd : permet de print le working directory. $PWD : contient le directory. 
Faire un programme qui lise un fichier texte et calcule le nombre d'occurrence des différents mots, trie puis affiche les mots à partir de  http://www.gutenberg.org/cache/epub/45495/pg45495.txt
(on utilise http://algs4.cs.princeton.edu/63suffix/mobydick.txt)
- Récupérer le texte avec ḋ wget Ṡ puis l'adresse ou au lieu d'enregistrer le fichier on peut directement travailler sur la sortie standard en ne téléchargeant pas le fichier 
- passer d'un texte à un ensemble de mot en supprimant les séparateurs, apostrophes, etc. en les transformant en espace à la place avec la commande ḋ tr Ṡ pour translate
- transformer le texte avec un mot par ligne 
- trouver le nombre d'occurrence de chaque mot
- trier
Pour l'instant on a donc : wget http://www.gutenberg.org/cache/epub/45495/pg45495.txt | tr -s -c [:alpha:] '\n'
-s : remplacer un élément par un autre
-c : les éléments qui devront être remplacés ce qui ne sont pas 
-[:alpha:] : caractères alphabétiques
-'\n' : retour à la ligne
Puis on ajoute | tr ḋ A-Z Ṡ ḋ a-z Ṡ
==> on indique un ḋ range Ṡ
Version finale cat mobydick.txt | tr -s -c [:alpha:] '\n' | tr  -s 'A-Z' 'a-z' | sort | uniq -c | sort -nr | head. 
==> Cat : affiche le fichier à traiter
==> Head : permet d'afficher seulement les 10 premiers.
Si l'on est bloqué à un moment on peut faire 'CTRL + D' afin de signaler la fin du traitement du fichier. 
En termes de performance, tout ce travail est très bon. 
history > cmds.txt permet de mettre l'historique des commandes entrées sur le terminal depuis le début et ce dans un fichier texte cmds.txt. 

TP 3 :

Projet : Télécharger plusieurs recettes depuis Marmiton.org ou 750g.com et les organiser par temps de cuisson. On peut penser à traiter plus de texte en cherchant à prendre un abstract des recettes (titre, temps de cuisson, etc.), soit les quelques premières lignes.

è Se rapproche du projet Allociné d’un autre groupe

Il faut penser au format du fichier dans lequel on va stocker les informations récupérées.

On pourra utiliser awk, curl (web scraping), grep (trouver un « string » en particulier). Il va falloir se renseigner sur leur utilisation.

On fera tout d’abord :

-          Aller sur une adresse URL de recherche, par exemple de cheese cake

-          On commence par récupérer les informations générales des recettes reçues en résultats suite à la recherche

-          On veut afficher seulement le titre, préparation, cuisson et le nombre de personnes (les 2 premières lignes) : elles sont dans les 5 lignes que donne chaque résultat par recette

-          On trie par le temps de cuisine générale le plus court

Emacs : on est dans un « text buffer », et non dans un terminal. Il permet d’utiliser plusieurs langages.

Unoconv : conversion par libre office d’un fichier.

Basename : nom sans l’extension

On fait :

cat /home/amelie/cheesecake pour ouvrir le fichier texte.

On va chercher dans les éléments awk et grep pour pouvoir récupérer certains éléments de notre fichier de recettes. On voudrait avoir le nom de la recette, donc première ligne et la dernière puis recommencer après le crochet de fin de chaque recette.

Pour afficher le premier champ : awk ‘{print $1}’ $cheesecake.txt

On pourrait simplifier en mettant une string à rechercher pour l’affichage du nom de recette comme ‘Recette : … .’. Du coup on pourrait mettre awk ‘’ /Recette:/,/./ ‘’ cheesecake.txt par exemple.

Une autre commande qui est plus simple est sed –n ‘’1 p’’ ~/cheesecake.txt. Cela affiche la première ligne.  P : print

Pour enlever les lignes avec le deuxième nom, les votes : grep –v  avec ‘’) :’’ et ‘’]’’

Une autre commande pourrait supprimer les lignes 2 à 4 de chaque recette afin de garder seulement les lignes 1 et 5 : sed –n ‘’2, 4d’’ cheesecake.txt. d : delete

On veut les 14 premiers champs de la ligne 5 pour récupérer jusqu’à la parenthèse fermée après le nombre de personnes pour laquelle la recette est faite.

 

12/05

Ctrl a : retour à la ligne

Ctrl i : aller à la fin

Ctrl l : nettoyer le terminal

Ctrl c :

Exit ou ctrl d : sortir du terminal

Ctrl r : chercher une commande écrite dans le terminal pendant une session

Installer des éléments sur un serveur 

-          Créer un fichier texte (ssh.txt) sur git avec notre nom (login que l’on veut utiliser sur le serveur) et notre clé publique

-          Permet de créer un utilisateur

-          Sudo : super user do

-          Si on écrit su et le nom d’un utilisateur, on est dans son dossier

-          Su ; cd : on est dans le root

-          On créé des utilisateurs afin d’être plus sécurisé

-          visudo : on peut modifier le fichier /etc/sudoer (permet de donner des permissions)

On récupère des repository : faire un script

Trouver les fichiers qui sont exécutables en faisant un dash f find. Avec ces fichiers exécutables, on cherche ensuite à les lancer : exec.

Comment rediriger les erreurs issues de l’exécution de tous les scripts ?

 

18/05/2014

Test de curl pour notre projet sur marmiton :

Utilisation de l’URL http://www.marmiton.org/recettes/recherche.aspx?aqt=cheesecake pour récupérer l’HTML de la page.

Installation de curl avec sudo apt-get install curl

Pour récupérer toutes les pages correspondant à la recherche « cheesecake », on peut les repérer grâce à une balise search result présente dans le HTML.

-o : même chose que > sauf que c’est plus propre et intégré à bash. Utilisé pour enregistrer les résultats après curl : curl http://www.marmiton.org/recettes/recherche.aspx?aqt=cheesecake –o projet_marmiton

less : permet d’afficher un fichier et met au début <> de cat qui fait dérouler le fichier. 


Semaine du 19/05 au 25/05 : 
Création d'un fichier marmiton.sh contenant curl -o page -s http://www.marmiton.org/recettes/recherche.aspx?aqt=$1
afin de récupérer le HTML de la page de résultat de recettes
$1 permet de récupérer le premier argument passé au script marmiton.sh

chmod +x marmiton.sh
Ainsi, $ ./marmiton.sh cheesecake
entraîne une requête "curl" sur la page de recherche cheesecake

Création d'un script SED qui permet d'extraire les titres contenu dans la page HTML de résultats.
sed -n -f titles.sed page

/.*<div class="m_search_titre_recette"><a href=.*>\(.*\)<\/a><\/div>/ { s//\1/p;}

.*: quelconques caractères autant de fois qu'il le faut
\( : permet de commencer à grouper des éléments
{}
s/../.. : substitute, / : délimiteur
\1 : garde une partie
p : permet de printer les lignes modifié
-> Une fois que la ligne est matchée on ne print (p) que le groupe trouvé \1.

marmiton.sh retourne donc désormais la liste des titres des recettes

TP 26/05 : 

A savoir pour l'examen : 

difference git clone htpps:// and git clone git@
public key
git add, git push, git commit
pull request
SaaS, PaaS, IaaS, connect to openshift, crate an application on openshift, monitor logs on openshift. 
Knowing how to connect to openshift through ssh (machine name, dedicated shared or virtual server)
ssh
LFS : /home, /usr/local/bin (pas accessible aux utilisateurs normaux),/var, /etc
Command line : terminal, bash, variable d'nvironnement, boucles, alias, variable d'environnement standard. 
Curl, sed
Misc : mua, mta, mda, configurer postfix avec un relayhost en utilisant mail

Pour le projet : 
Regex pour récupérer dans le HTML des pages de résultat en réutilisant les mêmes éléments que pour récupérer les titres :
- temps de préparation :
/.*<div class="m_search_tps_prepa">.*<\/strong>\(.*\)<\/div>/ { s//\1/p;}
- temps de cuisson :
/.*<div class="m_search_tps_cuisson">.*<\/strong>\(.*\)<\/div>/ { s//\1/p;}
- type de plat
/.*<div class="m_search_type_plat">\(.*\)<\/div>/ { s//\1/p;}

Update 28/05 : 
/.*<div class="m_search_result_part4">/,/<\/div>/ {
	N
	/.*(pour \([0-9]*\) personnes).*/{ s//\1/p};
}
Même technique pour récupérer le nombre de personnes contenu dans la description de la recette. La balise contient une grosse partie texte de laquelle il faut extraire seulement cette information. Le problème est que lorsque je teste cette regex, je ne récupère pas l'ensemble des personnes pour laquelle la recette est faite. Par ailleurs, parfois il ne s'agit pas du nombre de personnes mais du nombre de fruits pour laquelle la recette est faite. 


Up 29/05
Modification des regex déclarées le temps de préparation et le temps de cuisson avec ajout de ([0-9]*\)mn afin d'être plus précis.
La regex pour le nombre de personnes pose toujours un problème de récupération du nombre pour toutes les recettes. 

Chacune des regex a été ajoutée dans un seul fichier total.sed afin de ne pas répéter la même commande "sed -n -f..." psur chacun des fichiers séparés. 

Il reste à travailler sur : 
<div class="m_search_result_part4">
										        Préparation : 15 min Cuisson : 30 min Ingrédients (pour 8 personnes) : - 500 g de fromage blanc battu - 70 g de sucre en poudre - 1 cuillère à soupe de maïzena - 3 jaunes d'œufs - le zeste d'un citron vert - 1 paquet de gâteaux de type 'Bastogne' Préparation : Préchauffer le four à 180°C (thermostat&nbsp;[...]
									        </div>
afin de bien récupérer tous les "nombre de personnes" de chaque recette. 
Puis il faudra chercher un moyen de récupérer l'ensemble des résultats liés à une recherche (donc sur plusieurs pages) et classer les résultats dans un tableau afin de pouvoir les traiter selon les besoins. 

h -> permet de stocker dans le hold buffer de sed 
H -> permet d'ajouter après un saut de ligne les données dans le hold buffer
g -> permet de récupérer ce qu'il y a dans le hold buffer pour le traiter 
Tout ça permet de regrouper les infos liées à chaque recette pour qu'elles ne se print pas les unes à la suite des autres. 

Update 01/06
Modification du script sed : On remplace p par h et H à chaque fin de regex pour jouer avec le hold buffer et le pattern buffer comme vu plus haut.
Modification de la regex pour récupérer le nombre de 'personnes'. Comme il ne s'agit pas forcément du nombre de personnes mais parfois du nombre de fruits pour laquelle la recette est réalisée, il faut être moins précis dans la regex, en utilisant \(\w*\) pour matcher tout type de mot écrit après les chiffres et jusquà la parenthèse de fermeture. 
Ainsi la dernière regex est : 
/.*<div class="m_search_result_part4">/ {
	N
	/.*(pour \([0-9]*\) \(\w*\)).*/{ s//\1\r\n\2/;H;}
	g
	s/\r\n/;/gp
}
Les groupes 1 et 2 sont stockés dans la mémoire et séparés par un saut de ligne. Ensuite on récupère le tout, on sépare chaque élément  par un ';' et on print le tout. 
On récupère ainsi toute cette partie de description et ce pour tous les résultats. 

Le fichier marmiton.sh réalise désormais la récupération du contenus des 6 premières pages de résultats, mais peut en récupérer plus. 
Cela fonctionne grâce à une boucle for : 
for i in {0..50..10}
do
	curl...
done
L'URL utilisée par marmiton (hhttp://www.marmiton.org/recettes/recherche.aspx?aqt=$1) que l'on curl permet d'incrémenter un i de 10 en 10 pour attraper les pages que l'on souhaite en rajoutant '\&start=$i'.
Une fois la boucle for terminée on utilise la commande sed comme précédemment et on ajoute par concaténation le traitement des données récupérées :
sed -n -f total.sed /tmp/raw | sort --field-separator=';' -rn --key=$2 |column -t -s ";" 
On trie les données en séparant l'ensemble des éléments (titre, temps de cuisson, etc.) par des ';', dans un ordre décroissant numérique (pour obtenir celle avec le plus de votes) et donc seulement sur la colonne passée en second argument, représentée par 'key=$2', à savoir les votes. 

On utilise /tmp/raw d'une manière particulière de telle sorte à pouvoir ajouter les éléments les uns après les autres dans le fichier temporaire, et donc pour ne rien écraser.

Actuellement, afin de lancer le script, il faut par exemple taper './marmiton.sh baguette 2' car il y a besoin d'indiquer deux arguments à savoir ce que l'on recherche et le numéro de colonne des votes. 

La prochaine version serait de ne lancer le script qu'avec './marmiton.sh et ensuite de demander ce qui est recherché et par quoi on veut trier, plutôt que d'être limité au tri par votes. 

Update 04/06 : 
On demande à l'utilisateur ce qu'il désire rechercher à l'aide de 'echo' et on 'read' le mot entré par l'utilisateur. 
On utilise la même technique pour demander comment trier les données récupérées des pages web et on récupère dans le 'case' la variable utilisée pour stocker ce qui a été entré. 
En fonction de la colonne sélectionnée, la 'key' change.

Update 09/06 :
Lors des tests du script bash, il y avait des problèmes au niveau des éléments demandés à l'utilisateur. En effet, on peut entrer des noms de recettes incohérents (exemple : baguetttte) et l'erreur n'est pas gérée car le script ne repose pas la question mais s'arrête. De même, on pouvait entrer des lettres ou des chiffres ne correspondant pas à des colonnes pour trier. 
En ce qui concerne la deuxième erreur, une solution a pu être trouvée. On doit avant le 'case' définir une condition, à savoir tant que le nombre entré n'est pas un chiffre entre 1 et 6, on repose la même question à l'utilisateur. 
On définit ainsi une variable re stockant une regex correspondant aux nombres attendus : re='^[1-6]$'
Ensuite, on définit une boucle while prenant en condition notre variable. 
while ! [[ $num =~ $re ]]; do
	echo "You didn't enter the right command, please try again!";
	read num;
done

Update 10/06 : 
Le problème lié au nom de la recette entré à été réglé grâce à l'utilisation d'une 2ème commande curl et d'un grep pour afficher la ligne correspondant au pattern qu'on lui a fixé, ici "Aucun résultat" car dans le code HTML de la page on recherche la ligne "Aucun résultat ne correspond à votre recehrche.". On réutilise la même URL que précédemment mais sans la partie incrémentation des pages. 

while [[ $(curl -s http://www.marmiton.org/recettes/recherche.aspx?aqt=$recipe | grep "Aucun résultat") ]]; do
	echo "No results found. Please try again.";
	read recipe;

On a ajouté $() afin d'exécuter la commande de manière 'forcée'.

Des erreurs se produisent encore lorsque l'on rentre des noms de recettes comportant plusieurs mots séparés par des espaces et lorsque qu'un ou plusieurs mots comportent un ou plusieurs caractères spéciaux, comme '^'. 

Update : 
Les caractères spéciaux n'étant pas gérés, il faut pouvoir les enlever, ou en tout cas transformer le mot entré par l'utilisateur en quelque chose de lisible par le script et correspondant aux attentes des URL de Marmiton. 
Cela est réalisable avec sed mais est beaucoup plus progre grâce à iconv.
iconv permet de convertir d'un encodage à un autre. Celui qui nous intéresse est l'ASCII. On a besoin des 2 options -f et -t, ce qui nous a donné : 
recipe=$(iconv -f utf8 -t ascii//TRANSLIT <<< "$recipe")

En ce qui concerne les espaces, on les remplace par des tirets pour correspondre à la forme attendue par le script: 
recipe=${recipe// /-}

Afin de lancer le script en continu, nous avons mis une boucle while simple englobant la version du script précédente. 
while true; do
...
done
